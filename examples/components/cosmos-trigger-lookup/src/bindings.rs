// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
pub type AnyContract = lay3r::avs::layer_types::AnyContract;
pub type AnyEvent = lay3r::avs::layer_types::AnyEvent;
pub type ChainConfigs = lay3r::avs::layer_types::ChainConfigs;
#[derive(Clone)]
pub struct Input {
    pub chain_name: _rt::String,
    pub block_height: u64,
    pub contract: AnyContract,
    pub event: AnyEvent,
    pub chain_configs: ChainConfigs,
}
impl ::core::fmt::Debug for Input {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("Input")
            .field("chain-name", &self.chain_name)
            .field("block-height", &self.block_height)
            .field("contract", &self.contract)
            .field("event", &self.event)
            .field("chain-configs", &self.chain_configs)
            .finish()
    }
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn _export_run_cabi<T: Guest>(
    arg0: *mut u8,
    arg1: usize,
    arg2: i64,
    arg3: i32,
    arg4: *mut u8,
    arg5: usize,
    arg6: i32,
    arg7: i32,
    arg8: *mut u8,
    arg9: usize,
    arg10: *mut u8,
    arg11: usize,
    arg12: *mut u8,
    arg13: usize,
) -> *mut u8 {
    #[cfg(target_arch = "wasm32")]
    _rt::run_ctors_once();
    let len0 = arg1;
    let bytes0 = _rt::Vec::from_raw_parts(arg0.cast(), len0, len0);
    use lay3r::avs::layer_types::AnyContract as V3;
    let v3 = match arg3 {
        0 => {
            let e3 = {
                let len1 = arg5;
                _rt::Vec::from_raw_parts(arg4.cast(), len1, len1)
            };
            V3::Eth(e3)
        }
        n => {
            debug_assert_eq!(n, 1, "invalid enum discriminant");
            let e3 = {
                let len2 = arg5;
                let bytes2 = _rt::Vec::from_raw_parts(arg4.cast(), len2, len2);
                lay3r::avs::layer_types::CosmosContract {
                    bech32_addr: _rt::string_lift(bytes2),
                    prefix_len: arg6 as u32,
                }
            };
            V3::Cosmos(e3)
        }
    };
    use lay3r::avs::layer_types::AnyEvent as V17;
    let v17 = match arg7 {
        0 => {
            let e17 = {
                let base7 = arg8;
                let len7 = arg9;
                let mut result7 = _rt::Vec::with_capacity(len7);
                for i in 0..len7 {
                    let base = base7.add(i * 8);
                    let e7 = {
                        let l4 = *base.add(0).cast::<*mut u8>();
                        let l5 = *base.add(4).cast::<usize>();
                        let len6 = l5;
                        _rt::Vec::from_raw_parts(l4.cast(), len6, len6)
                    };
                    result7.push(e7);
                }
                _rt::cabi_dealloc(base7, len7 * 8, 4);
                let len8 = arg11;
                lay3r::avs::layer_types::EthEventLogData {
                    topics: result7,
                    data: _rt::Vec::from_raw_parts(arg10.cast(), len8, len8),
                }
            };
            V17::Eth(e17)
        }
        n => {
            debug_assert_eq!(n, 1, "invalid enum discriminant");
            let e17 = {
                let len9 = arg9;
                let bytes9 = _rt::Vec::from_raw_parts(arg8.cast(), len9, len9);
                let base16 = arg10;
                let len16 = arg11;
                let mut result16 = _rt::Vec::with_capacity(len16);
                for i in 0..len16 {
                    let base = base16.add(i * 16);
                    let e16 = {
                        let l10 = *base.add(0).cast::<*mut u8>();
                        let l11 = *base.add(4).cast::<usize>();
                        let len12 = l11;
                        let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);
                        let l13 = *base.add(8).cast::<*mut u8>();
                        let l14 = *base.add(12).cast::<usize>();
                        let len15 = l14;
                        let bytes15 = _rt::Vec::from_raw_parts(l13.cast(), len15, len15);
                        (_rt::string_lift(bytes12), _rt::string_lift(bytes15))
                    };
                    result16.push(e16);
                }
                _rt::cabi_dealloc(base16, len16 * 16, 4);
                lay3r::avs::layer_types::CosmosEvent {
                    ty: _rt::string_lift(bytes9),
                    attributes: result16,
                }
            };
            V17::Cosmos(e17)
        }
    };
    let base52 = arg12;
    let len52 = arg13;
    let mut result52 = _rt::Vec::with_capacity(len52);
    for i in 0..len52 {
        let base = base52.add(i * 76);
        let e52 = {
            let l18 = *base.add(0).cast::<*mut u8>();
            let l19 = *base.add(4).cast::<usize>();
            let len20 = l19;
            let bytes20 = _rt::Vec::from_raw_parts(l18.cast(), len20, len20);
            let l21 = i32::from(*base.add(8).cast::<u8>());
            use lay3r::avs::layer_types::AnyChainConfig as V51;
            let v51 = match l21 {
                0 => {
                    let e51 = {
                        let l22 = i32::from(*base.add(12).cast::<u8>());
                        let l26 = *base.add(24).cast::<*mut u8>();
                        let l27 = *base.add(28).cast::<usize>();
                        let len28 = l27;
                        let bytes28 = _rt::Vec::from_raw_parts(l26.cast(), len28, len28);
                        lay3r::avs::layer_types::EthChainConfig {
                            ws_endpoint: match l22 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l23 = *base.add(16).cast::<*mut u8>();
                                        let l24 = *base.add(20).cast::<usize>();
                                        let len25 = l24;
                                        let bytes25 =
                                            _rt::Vec::from_raw_parts(l23.cast(), len25, len25);
                                        _rt::string_lift(bytes25)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            http_endpoint: _rt::string_lift(bytes28),
                        }
                    };
                    V51::Eth(e51)
                }
                n => {
                    debug_assert_eq!(n, 1, "invalid enum discriminant");
                    let e51 = {
                        let l29 = *base.add(12).cast::<*mut u8>();
                        let l30 = *base.add(16).cast::<usize>();
                        let len31 = l30;
                        let bytes31 = _rt::Vec::from_raw_parts(l29.cast(), len31, len31);
                        let l32 = i32::from(*base.add(20).cast::<u8>());
                        let l36 = i32::from(*base.add(32).cast::<u8>());
                        let l40 = i32::from(*base.add(44).cast::<u8>());
                        let l44 = *base.add(56).cast::<f32>();
                        let l45 = *base.add(60).cast::<*mut u8>();
                        let l46 = *base.add(64).cast::<usize>();
                        let len47 = l46;
                        let bytes47 = _rt::Vec::from_raw_parts(l45.cast(), len47, len47);
                        let l48 = *base.add(68).cast::<*mut u8>();
                        let l49 = *base.add(72).cast::<usize>();
                        let len50 = l49;
                        let bytes50 = _rt::Vec::from_raw_parts(l48.cast(), len50, len50);
                        lay3r::avs::layer_types::CosmosChainConfig {
                            chain_id: _rt::string_lift(bytes31),
                            rpc_endpoint: match l32 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l33 = *base.add(24).cast::<*mut u8>();
                                        let l34 = *base.add(28).cast::<usize>();
                                        let len35 = l34;
                                        let bytes35 =
                                            _rt::Vec::from_raw_parts(l33.cast(), len35, len35);
                                        _rt::string_lift(bytes35)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            grpc_endpoint: match l36 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l37 = *base.add(36).cast::<*mut u8>();
                                        let l38 = *base.add(40).cast::<usize>();
                                        let len39 = l38;
                                        let bytes39 =
                                            _rt::Vec::from_raw_parts(l37.cast(), len39, len39);
                                        _rt::string_lift(bytes39)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            grpc_web_endpoint: match l40 {
                                0 => None,
                                1 => {
                                    let e = {
                                        let l41 = *base.add(48).cast::<*mut u8>();
                                        let l42 = *base.add(52).cast::<usize>();
                                        let len43 = l42;
                                        let bytes43 =
                                            _rt::Vec::from_raw_parts(l41.cast(), len43, len43);
                                        _rt::string_lift(bytes43)
                                    };
                                    Some(e)
                                }
                                _ => _rt::invalid_enum_discriminant(),
                            },
                            gas_price: l44,
                            gas_denom: _rt::string_lift(bytes47),
                            bech32_prefix: _rt::string_lift(bytes50),
                        }
                    };
                    V51::Cosmos(e51)
                }
            };
            (_rt::string_lift(bytes20), v51)
        };
        result52.push(e52);
    }
    _rt::cabi_dealloc(base52, len52 * 76, 4);
    let result53 = T::run(Input {
        chain_name: _rt::string_lift(bytes0),
        block_height: arg2 as u64,
        contract: v3,
        event: v17,
        chain_configs: result52,
    });
    let ptr54 = _RET_AREA.0.as_mut_ptr().cast::<u8>();
    match result53 {
        Ok(e) => {
            *ptr54.add(0).cast::<u8>() = (0i32) as u8;
            let vec55 = (e).into_boxed_slice();
            let ptr55 = vec55.as_ptr().cast::<u8>();
            let len55 = vec55.len();
            ::core::mem::forget(vec55);
            *ptr54.add(8).cast::<usize>() = len55;
            *ptr54.add(4).cast::<*mut u8>() = ptr55.cast_mut();
        }
        Err(e) => {
            *ptr54.add(0).cast::<u8>() = (1i32) as u8;
            let vec56 = (e.into_bytes()).into_boxed_slice();
            let ptr56 = vec56.as_ptr().cast::<u8>();
            let len56 = vec56.len();
            ::core::mem::forget(vec56);
            *ptr54.add(8).cast::<usize>() = len56;
            *ptr54.add(4).cast::<*mut u8>() = ptr56.cast_mut();
        }
    };
    ptr54
}
#[doc(hidden)]
#[allow(non_snake_case)]
pub unsafe fn __post_return_run<T: Guest>(arg0: *mut u8) {
    let l0 = i32::from(*arg0.add(0).cast::<u8>());
    match l0 {
        0 => {
            let l1 = *arg0.add(4).cast::<*mut u8>();
            let l2 = *arg0.add(8).cast::<usize>();
            let base3 = l1;
            let len3 = l2;
            _rt::cabi_dealloc(base3, len3 * 1, 1);
        }
        _ => {
            let l4 = *arg0.add(4).cast::<*mut u8>();
            let l5 = *arg0.add(8).cast::<usize>();
            _rt::cabi_dealloc(l4, l5, 1);
        }
    }
}
pub trait Guest {
    fn run(input: Input) -> Result<_rt::Vec<u8>, _rt::String>;
}
#[doc(hidden)]
macro_rules! __export_world_layer_any_contract_event_world_cabi {
    ($ty:ident with_types_in $($path_to_types:tt)*) => {
        const _ : () = { #[export_name = "run"] unsafe extern "C" fn export_run(arg0 : *
        mut u8, arg1 : usize, arg2 : i64, arg3 : i32, arg4 : * mut u8, arg5 : usize, arg6
        : i32, arg7 : i32, arg8 : * mut u8, arg9 : usize, arg10 : * mut u8, arg11 :
        usize, arg12 : * mut u8, arg13 : usize,) -> * mut u8 { $($path_to_types)*::
        _export_run_cabi::<$ty > (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8,
        arg9, arg10, arg11, arg12, arg13) } #[export_name = "cabi_post_run"] unsafe
        extern "C" fn _post_return_run(arg0 : * mut u8,) { $($path_to_types)*::
        __post_return_run::<$ty > (arg0) } };
    };
}
#[doc(hidden)]
pub(crate) use __export_world_layer_any_contract_event_world_cabi;
#[repr(align(4))]
struct _RetArea([::core::mem::MaybeUninit<u8>; 12]);
static mut _RET_AREA: _RetArea = _RetArea([::core::mem::MaybeUninit::uninit(); 12]);
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod lay3r {
    pub mod avs {
        #[allow(dead_code, clippy::all)]
        pub mod layer_types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[derive(Clone)]
            pub struct CosmosContract {
                pub bech32_addr: _rt::String,
                /// prefix is the first part of the bech32 address
                pub prefix_len: u32,
            }
            impl ::core::fmt::Debug for CosmosContract {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CosmosContract")
                        .field("bech32-addr", &self.bech32_addr)
                        .field("prefix-len", &self.prefix_len)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct CosmosEvent {
                pub ty: _rt::String,
                pub attributes: _rt::Vec<(_rt::String, _rt::String)>,
            }
            impl ::core::fmt::Debug for CosmosEvent {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CosmosEvent")
                        .field("ty", &self.ty)
                        .field("attributes", &self.attributes)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct CosmosChainConfig {
                pub chain_id: _rt::String,
                pub rpc_endpoint: Option<_rt::String>,
                pub grpc_endpoint: Option<_rt::String>,
                pub grpc_web_endpoint: Option<_rt::String>,
                pub gas_price: f32,
                pub gas_denom: _rt::String,
                pub bech32_prefix: _rt::String,
            }
            impl ::core::fmt::Debug for CosmosChainConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CosmosChainConfig")
                        .field("chain-id", &self.chain_id)
                        .field("rpc-endpoint", &self.rpc_endpoint)
                        .field("grpc-endpoint", &self.grpc_endpoint)
                        .field("grpc-web-endpoint", &self.grpc_web_endpoint)
                        .field("gas-price", &self.gas_price)
                        .field("gas-denom", &self.gas_denom)
                        .field("bech32-prefix", &self.bech32_prefix)
                        .finish()
                }
            }
            pub type EthContract = _rt::Vec<u8>;
            #[derive(Clone)]
            pub struct EthEventLogData {
                /// the raw log topics that can be decoded into an event
                pub topics: _rt::Vec<_rt::Vec<u8>>,
                /// the raw log data that can be decoded into an event
                pub data: _rt::Vec<u8>,
            }
            impl ::core::fmt::Debug for EthEventLogData {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("EthEventLogData")
                        .field("topics", &self.topics)
                        .field("data", &self.data)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct EthChainConfig {
                pub ws_endpoint: Option<_rt::String>,
                pub http_endpoint: _rt::String,
            }
            impl ::core::fmt::Debug for EthChainConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("EthChainConfig")
                        .field("ws-endpoint", &self.ws_endpoint)
                        .field("http-endpoint", &self.http_endpoint)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub enum AnyContract {
                Eth(_rt::Vec<u8>),
                Cosmos(CosmosContract),
            }
            impl ::core::fmt::Debug for AnyContract {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        AnyContract::Eth(e) => {
                            f.debug_tuple("AnyContract::Eth").field(e).finish()
                        }
                        AnyContract::Cosmos(e) => {
                            f.debug_tuple("AnyContract::Cosmos").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub enum AnyEvent {
                Eth(EthEventLogData),
                Cosmos(CosmosEvent),
            }
            impl ::core::fmt::Debug for AnyEvent {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        AnyEvent::Eth(e) => {
                            f.debug_tuple("AnyEvent::Eth").field(e).finish()
                        }
                        AnyEvent::Cosmos(e) => {
                            f.debug_tuple("AnyEvent::Cosmos").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub enum AnyChainConfig {
                Eth(EthChainConfig),
                Cosmos(CosmosChainConfig),
            }
            impl ::core::fmt::Debug for AnyChainConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        AnyChainConfig::Eth(e) => {
                            f.debug_tuple("AnyChainConfig::Eth").field(e).finish()
                        }
                        AnyChainConfig::Cosmos(e) => {
                            f.debug_tuple("AnyChainConfig::Cosmos").field(e).finish()
                        }
                    }
                }
            }
            pub type ChainConfigs = _rt::Vec<(_rt::String, AnyChainConfig)>;
        }
    }
}
#[rustfmt::skip]
mod _rt {
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    #[cfg(target_arch = "wasm32")]
    pub fn run_ctors_once() {
        wit_bindgen_rt::run_ctors_once();
    }
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            core::hint::unreachable_unchecked()
        }
    }
    extern crate alloc as alloc_crate;
    pub use alloc_crate::alloc;
}
/// Generates `#[no_mangle]` functions to export the specified type as the
/// root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]
macro_rules! __export_layer_any_contract_event_world_impl {
    ($ty:ident) => {
        self::export!($ty with_types_in self);
    };
    ($ty:ident with_types_in $($path_to_types_root:tt)*) => {
        $($path_to_types_root)*:: __export_world_layer_any_contract_event_world_cabi!($ty
        with_types_in $($path_to_types_root)*);
    };
}
#[doc(inline)]
pub(crate) use __export_layer_any_contract_event_world_impl as export;
#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.36.0:lay3r:avs@0.3.0:layer-any-contract-event-world:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 926] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\x89\x06\x01A\x02\x01\
A\x0e\x01B\x1a\x01r\x02\x0bbech32-addrs\x0aprefix-leny\x04\0\x0fcosmos-contract\x03\
\0\0\x01o\x02ss\x01p\x02\x01r\x02\x02tys\x0aattributes\x03\x04\0\x0ccosmos-event\
\x03\0\x04\x01ks\x01r\x07\x08chain-ids\x0crpc-endpoint\x06\x0dgrpc-endpoint\x06\x11\
grpc-web-endpoint\x06\x09gas-pricev\x09gas-denoms\x0dbech32-prefixs\x04\0\x13cos\
mos-chain-config\x03\0\x07\x01p}\x04\0\x0ceth-contract\x03\0\x09\x01p}\x01p\x0b\x01\
r\x02\x06topics\x0c\x04data\x0b\x04\0\x12eth-event-log-data\x03\0\x0d\x01r\x02\x0b\
ws-endpoint\x06\x0dhttp-endpoints\x04\0\x10eth-chain-config\x03\0\x0f\x01q\x02\x03\
eth\x01\x0b\0\x06cosmos\x01\x01\0\x04\0\x0cany-contract\x03\0\x11\x01q\x02\x03et\
h\x01\x0e\0\x06cosmos\x01\x05\0\x04\0\x09any-event\x03\0\x13\x01q\x02\x03eth\x01\
\x10\0\x06cosmos\x01\x08\0\x04\0\x10any-chain-config\x03\0\x15\x01o\x02s\x16\x01\
p\x17\x04\0\x0dchain-configs\x03\0\x18\x03\0\x1blay3r:avs/layer-types@0.3.0\x05\0\
\x02\x03\0\0\x0cany-contract\x03\0\x0cany-contract\x03\0\x01\x02\x03\0\0\x09any-\
event\x03\0\x09any-event\x03\0\x03\x02\x03\0\0\x0dchain-configs\x03\0\x0dchain-c\
onfigs\x03\0\x05\x01r\x05\x0achain-names\x0cblock-heightw\x08contract\x02\x05eve\
nt\x04\x0dchain-configs\x06\x03\0\x05input\x03\0\x07\x01p}\x01j\x01\x09\x01s\x01\
@\x01\x05input\x08\0\x0a\x04\0\x03run\x01\x0b\x04\0.lay3r:avs/layer-any-contract\
-event-world@0.3.0\x04\0\x0b$\x01\0\x1elayer-any-contract-event-world\x03\0\0\0G\
\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.220.0\x10wit-bindgen\
-rust\x060.36.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
