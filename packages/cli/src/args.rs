use std::{
    num::{NonZeroU32, NonZeroU64},
    path::PathBuf,
};

use clap::{arg, Parser, Subcommand};
use serde::{Deserialize, Serialize};
use utils::{
    config::{CliEnvExt, ConfigBuilder},
    serde::deserialize_vec_string,
};
use wasm_pkg_client::{PackageRef, Version};
use wavs_types::{ChainName, Digest, ServiceID, Timestamp, WorkflowID};

use crate::config::Config;

#[derive(Parser)]
#[command(version, about, long_about = None)]
pub enum Command {
    /// Uploads a WASI component
    UploadComponent {
        /// Path to the WASI component
        component_path: String,

        #[clap(flatten)]
        args: CliArgs,
    },

    /// # Description
    /// Deploys a service by loading its definition from a URL. The URL can be:
    /// - http:// or https:// pointing to a JSON service definition
    /// - ipfs:// with a valid CID as the host (e.g., ipfs://bafybeigdyrzt5sfp7udm7hu76uh7y26nf3efuylqabf3oclgtqy55fbzdi)
    ///
    /// # Prerequisites
    /// - Core contracts must have been previously deployed via the CLI
    /// - Service components must already be uploaded
    /// - Operators must already be registered on the contracts
    ///
    /// # Parameters
    /// * `service_url`: URL pointing to the JSON service definition
    /// * `set_url`: Boolean indicating whether to also set the URL on the service manager
    /// * `args`: Additional CLI arguments for the deployment operation
    DeployService {
        #[clap(long)]
        service_url: String,

        #[clap(long)]
        set_url: bool,

        #[clap(flatten)]
        args: CliArgs,
    },

    /// Execute a component directly, without going through WAVS
    /// Env vars starting with the "WAVS_ENV" prefix will be picked up by the component.
    Exec {
        /// Path to the WASI component
        /// The component must implement the trigger-world WIT
        #[clap(long)]
        component: String,

        #[clap(flatten)]
        args: CliArgs,

        /// The payload data.
        /// If preceded by a `@`, will be treated as a file path
        /// If preceded by a `0x`, will be treated as hex-encoded
        /// Otherwise will be treated as raw string bytes
        #[clap(long)]
        input: String,

        /// Optional fuel limit for component execution
        #[clap(long)]
        fuel_limit: Option<u64>,

        /// Optional time limit (seconds) for component execution
        #[clap(long)]
        time_limit: Option<u64>,

        /// Component config in KEY=VALUE format, comma-separated: --config a=1,b=2
        #[clap(long, value_delimiter = ',')]
        config: Vec<String>,
    },

    /// Service management commands
    Service {
        #[clap(subcommand)]
        command: ServiceCommand,

        /// Output file path
        #[clap(long, short, default_value = "./service.json")]
        file: PathBuf,

        #[clap(flatten)]
        args: CliArgs,
    },
}

/// Commands for managing services
#[derive(Debug, Subcommand, Clone, Serialize, Deserialize)]
pub enum ServiceCommand {
    /// Generates a new Service JSON.
    Init {
        /// The name of the service (required)
        #[clap(long)]
        name: String,

        /// The ID of the service (optional, autogenerated uuid v7 if not supplied)
        #[clap(long)]
        id: Option<ServiceID>,
    },
    /// Workflow management commands
    Workflow {
        #[clap(subcommand)]
        command: WorkflowCommand,
    },
    /// Operations on service manager
    Manager {
        #[clap(subcommand)]
        command: ManagerCommand,
    },
    /// Validates the service JSON
    Validate {},
}

/// Commands for managing components
#[derive(Debug, Subcommand, Clone, Serialize, Deserialize)]
pub enum ComponentCommand {
    /// Set a component using a digest
    SetSourceDigest {
        /// The digest of the component to set
        #[clap(long)]
        digest: Digest,
    },
    /// Set a component using a registry package reference
    SetSourceRegistry {
        /// Optional domain for the registry (omit for default)
        #[clap(long)]
        domain: Option<String>,

        /// The package reference (e.g., "namespace/name@version")
        #[clap(long)]
        package: PackageRef,

        /// Optional version to use (omit for latest)
        #[clap(long)]
        version: Option<Version>,
    },
    /// Manage permissions of a workflow component
    Permissions {
        /// HTTP hosts allowed for access:
        /// Use --http-hosts '' to disallow all hosts
        /// Use --http-hosts '*' to allow all hosts
        /// Use --http-hosts 'host1,host2,...' to allow specific hosts
        /// Omit to leave HTTP permissions unchanged
        #[clap(long, value_delimiter = ',')]
        http_hosts: Option<Vec<String>>,

        /// Enable file system access
        #[clap(long)]
        file_system: Option<bool>,
    },
    /// Manage the fuel limit of a workflow component
    FuelLimit {
        /// Fuel limit value (omit to use default)
        #[clap(long)]
        fuel: Option<u64>,
    },
    /// Set maximum execution time for a workflow component
    TimeLimit {
        /// Maximum execution time in seconds (omit to use default)
        #[clap(long)]
        seconds: Option<u64>,
    },
    /// Manage the workflow component config (KV)
    Config {
        /// Configuration key-value pairs in format 'key=value'
        /// Omit to clear all config values
        #[clap(long, value_delimiter = ',')]
        values: Option<Vec<String>>,
    },
    /// Manage the workflow component env
    Env {
        /// Env values staring with 'WAVS_ENV'
        #[clap(long, value_delimiter = ',')]
        values: Option<Vec<String>>,
    },
}

#[derive(Debug, Subcommand, Clone, Serialize, Deserialize)]
pub enum WorkflowCommand {
    /// Add a workflow to a service
    Add {
        /// The ID of the workflow (optional, autogenerated if not supplied)
        #[clap(long)]
        id: Option<WorkflowID>,
    },
    /// Delete a workflow from a service
    Delete {
        /// The ID of the workflow to delete
        #[clap(long)]
        id: WorkflowID,
    },
    /// Component management commands
    Component {
        /// The ID of the workflow to edit
        #[clap(long)]
        id: WorkflowID,
        #[clap(subcommand)]
        command: ComponentCommand,
    },
    /// Operations on workflow triggers
    Trigger {
        #[clap(long)]
        id: WorkflowID,
        #[clap(subcommand)]
        command: TriggerCommand,
    },
    /// Operations on workflow submits
    Submit {
        #[clap(long)]
        id: WorkflowID,
        #[clap(subcommand)]
        command: SubmitCommand,
    },
}

#[derive(Debug, Subcommand, Clone, Serialize, Deserialize)]
pub enum ManagerCommand {
    /// Sets an EVM service manager
    SetEvm {
        #[clap(long)]
        chain_name: ChainName,
        #[clap(long)]
        address: alloy_primitives::Address,
    },
}

#[derive(Debug, Subcommand, Clone, Serialize, Deserialize)]
pub enum TriggerCommand {
    /// Set a Cosmos contract event trigger for a workflow
    SetCosmos {
        /// The bech32 contract address (e.g., "cosmos1...")
        #[clap(long)]
        address: String,

        /// The chain name (e.g., "cosmoshub-4")
        #[clap(long)]
        chain_name: ChainName,

        /// The event type to listen for
        #[clap(long)]
        event_type: String,
    },

    /// Set an EVM contract event trigger for a workflow
    SetEvm {
        /// The hexadecimal EVM address (e.g., "0x1234...")
        #[clap(long)]
        address: alloy_primitives::Address,

        /// The chain name (e.g., "ethereum-mainnet")
        #[clap(long)]
        chain_name: ChainName,

        /// The event hash as a hex string (32 bytes)
        #[clap(long)]
        event_hash: String,
    },

    /// Set a block interval trigger for a workflow
    SetBlockInterval {
        #[clap(long)]
        chain_name: ChainName,
        #[clap(long)]
        n_blocks: NonZeroU32,

        /// Optional start block
        #[clap(long)]
        start_block: Option<NonZeroU64>,

        /// Optional end block height
        #[clap(long)]
        end_block: Option<NonZeroU64>,
    },

    /// Set a cron trigger for a workflow
    SetCron {
        /// A cron expression defining the schedule for execution.
        #[clap(long)]
        schedule: cron::Schedule,

        /// Optional start time (timestamp in nanoseconds)
        #[clap(long)]
        start_time: Option<Timestamp>,

        /// Optional end time (timestamp in nanoseconds)
        #[clap(long)]
        end_time: Option<Timestamp>,
    },
}

#[derive(Debug, Subcommand, Clone, Serialize, Deserialize)]
pub enum SubmitCommand {
    /// Set an EVM submit for a workflow
    SetEvm {
        /// The hexadecimal EVM address (e.g., "0x1234...")
        #[clap(long)]
        address: alloy_primitives::Address,

        /// The chain name (e.g., "ethereum-mainnet")
        #[clap(long)]
        chain_name: ChainName,

        /// The maximum gas to use for the submission (optional)
        #[clap(long)]
        max_gas: Option<u64>,
    },
    /// Set an aggregator submit for a workflow
    SetAggregator {
        /// The URL of the aggregator
        #[clap(long)]
        url: String,

        /// The hexadecimal EVM address (e.g., "0x1234...")
        #[clap(long)]
        address: alloy_primitives::Address,

        /// The chain name (e.g., "ethereum-mainnet")
        #[clap(long)]
        chain_name: ChainName,

        /// The maximum gas to use for the submission (optional)
        #[clap(long)]
        max_gas: Option<u64>,
    },
}

impl Command {
    pub fn args(&self) -> CliArgs {
        let args = match self {
            Self::DeployService { args, .. } => args,
            Self::UploadComponent { args, .. } => args,
            Self::Exec { args, .. } => args,
            Self::Service { args, .. } => args,
        };

        args.clone()
    }

    pub fn config(&self) -> Config {
        ConfigBuilder::new(self.args()).build().unwrap()
    }
}

/// This struct is used for both args and environment variables
/// the basic idea is that every env var can be overriden by a cli arg
/// and these override the config file
/// env vars follow the pattern of WAVS_CLI_{UPPERCASE_ARG_NAME}
#[derive(Clone, Debug, Parser, Serialize, Deserialize, Default)]
#[command(version, about, long_about = None)]
#[serde(default)]
pub struct CliArgs {
    /// The home directory of the application, where the cli.toml configuration file is stored
    /// if not provided here or in an env var, a series of default directories will be tried
    #[arg(long)]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub home: Option<PathBuf>,

    /// The WAVS endpoint. Default is `http://127.0.0.1:8000`
    #[arg(long)]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub wavs_endpoint: Option<PathBuf>,

    /// The path to an optional dotenv file to try and load
    /// if not set, will be the current working directory's .env
    #[arg(long)]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dotenv: Option<PathBuf>,

    /// Log level in the format of comma-separated tracing directives.
    /// Default is "info"
    #[arg(long, value_delimiter = ',')]
    #[serde(skip_serializing_if = "Vec::is_empty")]
    #[serde(deserialize_with = "deserialize_vec_string")]
    pub log_level: Vec<String>,

    /// The directory to store all internal data files
    /// Default is /var/wavs-cli
    #[arg(long)]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<PathBuf>,

    /// EVM credential for signing transactions (can be a mnemonic or private key)
    /// Usually leave this as None and override in env
    #[arg(long)]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub evm_credential: Option<String>,

    /// cosmos mnemonic (usually leave this as None and override in env)
    #[arg(long)]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cosmos_mnemonic: Option<String>,

    /// Save the deployment (default is true)
    #[arg(long)]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub save_deployment: Option<bool>,

    /// Do not display the results
    #[arg(long)]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub quiet_results: Option<bool>,

    /// Returns result as JSON
    #[arg(long)]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub json: Option<bool>,

    /// The IPFS gateway URL used to access IPFS content over HTTP.
    #[arg(long)]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub ipfs_gateway: Option<String>,
}

impl CliEnvExt for CliArgs {
    const ENV_VAR_PREFIX: &'static str = "WAVS_CLI";
    const TOML_IDENTIFIER: &'static str = "cli";

    fn home_dir(&self) -> Option<PathBuf> {
        self.home.clone()
    }

    fn dotenv_path(&self) -> Option<PathBuf> {
        self.dotenv.clone()
    }
}
