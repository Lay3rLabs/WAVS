package lay3r:avs@0.3.0;

use wasi:io/poll@0.2.0;
use wasi:clocks/monotonic-clock@0.2.0;
use wasi:io/error@0.2.0;
use wasi:io/streams@0.2.0;
use wasi:http/types@0.2.0 as http-types;
use wasi:http/outgoing-handler@0.2.0 as http-outgoing-handler;

interface layer-types {
  variant address {
    eth(list<u8>),
    // the bech32-encoded address, and length of the prefix
    cosmos(tuple<string, u32>)
  }

  record contract {
    address: address,
    chain-id: string
  }

  // An alloy log can be recreated with the info here 
  record eth-log {
    // the raw log topics that can be decoded into an event
    topics: list<list<u8>>,
    // the raw log data that can be decoded into an event
    data: list<u8>,
  }
}

world layer-chain-event-world {
  use layer-types.{contract};

  // event-data is emitted from the chain via a specific event type
  // which WAVS knows how to extract
  export run: func(contract: contract, event-data: list<u8>) -> result<list<u8>, string>;
}

world layer-eth-log-world {
  use layer-types.{contract, eth-log};

  export run: func(contract: contract, log: eth-log) -> result<list<u8>, string>;
}

world layer-raw-world {
  export run: func(input: list<u8>) -> result<list<u8>, string>;
}

world layer-sdk-world {
  use layer-types.{address, contract, eth-log};
}