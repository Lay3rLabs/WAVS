// Generated by `wit-bindgen` 0.36.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod lay3r {
    pub mod avs {
        #[allow(dead_code, clippy::all)]
        pub mod layer_types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[derive(Clone)]
            pub struct CosmosContract {
                pub bech32_addr: _rt::String,
                /// prefix is the first part of the bech32 address
                pub prefix_len: u32,
            }
            impl ::core::fmt::Debug for CosmosContract {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CosmosContract")
                        .field("bech32-addr", &self.bech32_addr)
                        .field("prefix-len", &self.prefix_len)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct CosmosEvent {
                pub ty: _rt::String,
                pub attributes: _rt::Vec<(_rt::String, _rt::String)>,
            }
            impl ::core::fmt::Debug for CosmosEvent {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CosmosEvent")
                        .field("ty", &self.ty)
                        .field("attributes", &self.attributes)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct CosmosChainConfig {
                pub chain_id: _rt::String,
                pub rpc_endpoint: Option<_rt::String>,
                pub grpc_endpoint: Option<_rt::String>,
                pub grpc_web_endpoint: Option<_rt::String>,
                pub gas_price: f32,
                pub gas_denom: _rt::String,
                pub bech32_prefix: _rt::String,
            }
            impl ::core::fmt::Debug for CosmosChainConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("CosmosChainConfig")
                        .field("chain-id", &self.chain_id)
                        .field("rpc-endpoint", &self.rpc_endpoint)
                        .field("grpc-endpoint", &self.grpc_endpoint)
                        .field("grpc-web-endpoint", &self.grpc_web_endpoint)
                        .field("gas-price", &self.gas_price)
                        .field("gas-denom", &self.gas_denom)
                        .field("bech32-prefix", &self.bech32_prefix)
                        .finish()
                }
            }
            pub type EthContract = _rt::Vec<u8>;
            #[derive(Clone)]
            pub struct EthEventLogData {
                /// the raw log topics that can be decoded into an event
                pub topics: _rt::Vec<_rt::Vec<u8>>,
                /// the raw log data that can be decoded into an event
                pub data: _rt::Vec<u8>,
            }
            impl ::core::fmt::Debug for EthEventLogData {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("EthEventLogData")
                        .field("topics", &self.topics)
                        .field("data", &self.data)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct EthChainConfig {
                pub ws_endpoint: Option<_rt::String>,
                pub http_endpoint: _rt::String,
            }
            impl ::core::fmt::Debug for EthChainConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("EthChainConfig")
                        .field("ws-endpoint", &self.ws_endpoint)
                        .field("http-endpoint", &self.http_endpoint)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub enum AnyContract {
                Eth(_rt::Vec<u8>),
                Cosmos(CosmosContract),
            }
            impl ::core::fmt::Debug for AnyContract {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        AnyContract::Eth(e) => {
                            f.debug_tuple("AnyContract::Eth").field(e).finish()
                        }
                        AnyContract::Cosmos(e) => {
                            f.debug_tuple("AnyContract::Cosmos").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub enum AnyEvent {
                Eth(EthEventLogData),
                Cosmos(CosmosEvent),
            }
            impl ::core::fmt::Debug for AnyEvent {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        AnyEvent::Eth(e) => {
                            f.debug_tuple("AnyEvent::Eth").field(e).finish()
                        }
                        AnyEvent::Cosmos(e) => {
                            f.debug_tuple("AnyEvent::Cosmos").field(e).finish()
                        }
                    }
                }
            }
            #[derive(Clone)]
            pub enum AnyChainConfig {
                Eth(EthChainConfig),
                Cosmos(CosmosChainConfig),
            }
            impl ::core::fmt::Debug for AnyChainConfig {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        AnyChainConfig::Eth(e) => {
                            f.debug_tuple("AnyChainConfig::Eth").field(e).finish()
                        }
                        AnyChainConfig::Cosmos(e) => {
                            f.debug_tuple("AnyChainConfig::Cosmos").field(e).finish()
                        }
                    }
                }
            }
            pub type ChainConfigs = _rt::Vec<(_rt::String, AnyChainConfig)>;
        }
    }
}
#[rustfmt::skip]
mod _rt {
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    extern crate alloc as alloc_crate;
}
#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.36.0:lay3r:avs@0.3.0:layer-sdk-world:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1088] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xba\x07\x01A\x02\x01\
A\x16\x01B\x1a\x01r\x02\x0bbech32-addrs\x0aprefix-leny\x04\0\x0fcosmos-contract\x03\
\0\0\x01o\x02ss\x01p\x02\x01r\x02\x02tys\x0aattributes\x03\x04\0\x0ccosmos-event\
\x03\0\x04\x01ks\x01r\x07\x08chain-ids\x0crpc-endpoint\x06\x0dgrpc-endpoint\x06\x11\
grpc-web-endpoint\x06\x09gas-pricev\x09gas-denoms\x0dbech32-prefixs\x04\0\x13cos\
mos-chain-config\x03\0\x07\x01p}\x04\0\x0ceth-contract\x03\0\x09\x01p}\x01p\x0b\x01\
r\x02\x06topics\x0c\x04data\x0b\x04\0\x12eth-event-log-data\x03\0\x0d\x01r\x02\x0b\
ws-endpoint\x06\x0dhttp-endpoints\x04\0\x10eth-chain-config\x03\0\x0f\x01q\x02\x03\
eth\x01\x0b\0\x06cosmos\x01\x01\0\x04\0\x0cany-contract\x03\0\x11\x01q\x02\x03et\
h\x01\x0e\0\x06cosmos\x01\x05\0\x04\0\x09any-event\x03\0\x13\x01q\x02\x03eth\x01\
\x10\0\x06cosmos\x01\x08\0\x04\0\x10any-chain-config\x03\0\x15\x01o\x02s\x16\x01\
p\x17\x04\0\x0dchain-configs\x03\0\x18\x03\0\x1blay3r:avs/layer-types@0.3.0\x05\0\
\x02\x03\0\0\x0fcosmos-contract\x03\0\x0fcosmos-contract\x03\0\x01\x02\x03\0\0\x0c\
cosmos-event\x03\0\x0ccosmos-event\x03\0\x03\x02\x03\0\0\x13cosmos-chain-config\x03\
\0\x13cosmos-chain-config\x03\0\x05\x02\x03\0\0\x0ceth-contract\x03\0\x0ceth-con\
tract\x03\0\x07\x02\x03\0\0\x12eth-event-log-data\x03\0\x12eth-event-log-data\x03\
\0\x09\x02\x03\0\0\x10eth-chain-config\x03\0\x10eth-chain-config\x03\0\x0b\x02\x03\
\0\0\x0cany-contract\x03\0\x0cany-contract\x03\0\x0d\x02\x03\0\0\x09any-event\x03\
\0\x09any-event\x03\0\x0f\x02\x03\0\0\x10any-chain-config\x03\0\x10any-chain-con\
fig\x03\0\x11\x02\x03\0\0\x0dchain-configs\x03\0\x0dchain-configs\x03\0\x13\x04\0\
\x1flay3r:avs/layer-sdk-world@0.3.0\x04\0\x0b\x15\x01\0\x0flayer-sdk-world\x03\0\
\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.220.0\x10wit-bi\
ndgen-rust\x060.36.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
